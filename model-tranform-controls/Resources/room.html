<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Luxurious Isometric Living Room</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/USDZLoader.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
    <script>
        // Debug function to send messages to iOS
        function sendToiOS(message) {
            if (window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers.iosNative) {
                window.webkit.messageHandlers.iosNative.postMessage(message);
            } else {
                console.log("iOS message handler not found:", message);
            }
        }

        // Add error event listener
        window.addEventListener('error', function(e) {
            sendToiOS({
                type: 'error',
                message: e.message,
                filename: e.filename,
                lineno: e.lineno,
                colno: e.colno
            });
        });

        // Check Three.js loading
        window.addEventListener('load', function() {
            if (typeof THREE === 'undefined') {
                sendToiOS({
                    type: 'error',
                    message: 'Three.js failed to load'
                });
            } else {
                sendToiOS({
                    type: 'success',
                    message: 'Three.js loaded successfully'
                });
            }
        });
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 50%, #f093fb 100%);
            overflow: hidden;
            height: 100vh;
        }
        
        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        
        #info {
            position: absolute;
            top: 30px;
            left: 30px;
            color: white;
            background: rgba(20, 20, 20, 0.8);
            padding: 20px;
            border-radius: 20px;
            backdrop-filter: blur(20px);
            z-index: 100;
            font-size: 14px;
            max-width: 350px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
        }
        
        #info h3 {
            margin-bottom: 15px;
            font-weight: 600;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        #info p {
            margin-bottom: 8px;
            opacity: 0.9;
        }
        
        #particles {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }
        
        .particle {
            position: absolute;
            width: 4px;
            height: 4px;
            background: rgba(255, 255, 255, 0.6);
            border-radius: 50%;
            animation: float 6s ease-in-out infinite;
        }
        
        @keyframes float {
            0%, 100% { transform: translateY(0px) rotate(0deg); opacity: 0.6; }
            50% { transform: translateY(-20px) rotate(180deg); opacity: 1; }
        }
        
        @media (max-width: 768px) {
            #info {
                font-size: 12px;
                padding: 15px;
                max-width: 280px;
                top: 20px;
                left: 20px;
            }
        }
    </style>
</head>
<body>
    <div id="particles"></div>
    <div id="container"></div>
    <div id="info">
        <h3>‚ú® Luxurious Living Space</h3>
        <p>üéÆ Drag to explore the room</p>
        <p>üîç Scroll to zoom in/out</p>
        <p>üåü Watch magical animations!</p>
        <p>üí´ Floating particles & glowing effects</p>
    </div>

    <script>
        // Enhanced scene setup
        let scene, camera, renderer;
        let animatedObjects = [];
        let particles = [];
        let clock = new THREE.Clock();
        let composer, renderPass, bloomPass;

        // Check WebGL compatibility
        function checkWebGL() {
            const canvas = document.createElement('canvas');
            const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
            
            if (!gl) {
                sendToiOS({
                    type: 'error',
                    message: 'WebGL not supported'
                });
                return false;
            }
            
            const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
            if (debugInfo) {
                const vendor = gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL);
                const renderer = gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL);
                sendToiOS({
                    type: 'info',
                    message: 'WebGL Info',
                    vendor: vendor,
                    renderer: renderer
                });
            }
            
            return true;
        }
        
        // Rich color palette
        const colors = {
            floor: 0x3a2827,
            floorPattern: 0x4a3837,
            walls: 0xf8f9fa,
            wallAccent: 0xe9ecef,
            sofa: 0x6366f1,
            sofaCushion: 0x4f46e5,
            table: 0x8b5a3c,
            tableTop: 0xa0522d,
            lamp: 0xffd700,
            lampGlow: 0xffeaa7,
            plant: 0x00b894,
            plantPot: 0x6c5ce7,
            tv: 0x2d3436,
            tvGlow: 0x74b9ff,
            rug: 0xe84393,
            rugPattern: 0xfd79a8,
            books: [0xff6b6b, 0x4ecdc4, 0x45b7d1, 0x96ceb4, 0xfeca57, 0xff9ff3],
            pillows: [0xff7675, 0x74b9ff, 0x55a3ff, 0x00b894],
            paintings: [0xfd79a8, 0xfdcb6e, 0x6c5ce7, 0xe84393]
        };
        
        function init() {
            // Check WebGL compatibility first
            if (!checkWebGL()) {
                return;
            }

            sendToiOS({
                type: 'info',
                message: 'Starting scene initialization'
            });

            try {
                // Create scene with fog for depth
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x667eea); // Match gradient background
                scene.fog = new THREE.Fog(0x667eea, 50, 100);
                
                sendToiOS({
                    type: 'info',
                    message: 'Scene created successfully'
                });

                // Enhanced camera with better initial position
                const aspect = window.innerWidth / window.innerHeight;
                const d = 25;
                camera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, 1, 1000);
                camera.position.set(35, 35, 35);
                camera.lookAt(0, 5, 0);
                
                sendToiOS({
                    type: 'info',
                    message: 'Camera initialized'
                });

                // Enhanced renderer with better quality settings
                renderer = new THREE.WebGLRenderer({ 
                    antialias: true, 
                    alpha: true,
                    powerPreference: "high-performance"
                });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                renderer.toneMapping = THREE.ACESFilmicToneMapping;
                renderer.toneMappingExposure = 1.2;
                renderer.outputEncoding = THREE.sRGBEncoding;
                document.getElementById('container').appendChild(renderer.domElement);
                
                sendToiOS({
                    type: 'info',
                    message: 'Renderer initialized successfully'
                });

                // Enhanced lighting
                setupLights();
                sendToiOS({
                    type: 'info',
                    message: 'Lights setup complete'
                });

                // Add room
                createRoom();
                sendToiOS({
                    type: 'info',
                    message: 'Room created successfully'
                });

                // Setup controls
                setupControls();
                sendToiOS({
                    type: 'info',
                    message: 'Controls initialized'
                });

                // Start animation
                animate();
                sendToiOS({
                    type: 'info',
                    message: 'Animation started'
                });
            } catch (error) {
                sendToiOS({
                    type: 'error',
                    message: 'Initialization error: ' + error.message,
                    stack: error.stack
                });
            }        function createDetailedRoom() {
            // Patterned floor
            const floorGeometry = new THREE.PlaneGeometry(30, 30);
            const floorMaterial = new THREE.MeshLambertMaterial({ color: colors.floor });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);

            // Floor tiles pattern
            for (let i = -7; i <= 7; i++) {
                for (let j = -7; j <= 7; j++) {
                    if ((i + j) % 2 === 0) {
                        const tileGeometry = new THREE.PlaneGeometry(2, 2);
                        const tileMaterial = new THREE.MeshLambertMaterial({ color: colors.floorPattern });
                        const tile = new THREE.Mesh(tileGeometry, tileMaterial);
                        tile.rotation.x = -Math.PI / 2;
                        tile.position.set(i * 2, 0.01, j * 2);
                        tile.receiveShadow = true;
                        scene.add(tile);
                    }
                }
            }

            // Walls
            const wallMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xcccccc,
                roughness: 0.5 
            });

            // Back wall
            const backWall = new THREE.Mesh(
                new THREE.PlaneGeometry(20, 10),
                wallMaterial
            );
            backWall.position.z = -10;
            backWall.position.y = 5;
            backWall.receiveShadow = true;
            scene.add(backWall);

            // Side wall
            const sideWall = new THREE.Mesh(
                new THREE.PlaneGeometry(20, 10),
                wallMaterial
            );
            sideWall.position.x = -10;
            sideWall.position.y = 5;
            sideWall.rotation.y = Math.PI / 2;
            sideWall.receiveShadow = true;
            scene.add(sideWall);

            // Add some furniture
            createFurniture();
        }

        function createFurniture() {
            // Simple couch
            const couchGeometry = new THREE.BoxGeometry(4, 1, 2);
            const couchMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x4a90e2,
                roughness: 0.7
            });
            const couch = new THREE.Mesh(couchGeometry, couchMaterial);
            couch.position.set(-2, 0.5, -8);
            couch.castShadow = true;
            scene.add(couch);

            // Coffee table
            const tableGeometry = new THREE.BoxGeometry(2, 0.5, 1);
            const tableMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x8b4513,
                roughness: 0.6
            });
            const table = new THREE.Mesh(tableGeometry, tableMaterial);
            table.position.set(-2, 0.25, -6);
            table.castShadow = true;
            scene.add(table);

            // Add some decorative items
            createDecorativeItems();
        }

        function createDecorativeItems() {
            // Plant
            const potGeometry = new THREE.CylinderGeometry(0.3, 0.2, 0.5);
            const potMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x654321,
                roughness: 0.8
            });
            const pot = new THREE.Mesh(potGeometry, potMaterial);
            pot.position.set(-4, 0.25, -8);
            pot.castShadow = true;
            scene.add(pot);

            // Plant leaves (simple spheres)
            const leafGeometry = new THREE.SphereGeometry(0.3);
            const leafMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x228b22,
                roughness: 0.9
            });
            
            for(let i = 0; i < 3; i++) {
                const leaf = new THREE.Mesh(leafGeometry, leafMaterial);
                leaf.position.set(
                    -4 + (Math.random() - 0.5) * 0.3,
                    0.8 + (Math.random() * 0.3),
                    -8 + (Math.random() - 0.5) * 0.3
                );
                leaf.castShadow = true;
                scene.add(leaf);
            }
        }

        function setupControls() {
            let isDragging = false;
            let previousPosition = {
                x: 0,
                y: 0
            };
            let currentRotation = {
                x: 0,
                y: 0
            };
            let targetRotation = {
                x: 0,
                y: 0
            };

            // Handle both touch and mouse events
            function getPosition(event) {
                // Touch event
                if (event.touches && event.touches.length > 0) {
                    return {
                        x: event.touches[0].clientX,
                        y: event.touches[0].clientY
                    };
                }
                // Mouse event
                return {
                    x: event.clientX,
                    y: event.clientY
                };
            }

            // Smooth animation for rotation
            function updateRotation() {
                currentRotation.x += (targetRotation.x - currentRotation.x) * 0.1;
                currentRotation.y += (targetRotation.y - currentRotation.y) * 0.1;
                
                scene.rotation.x = currentRotation.x;
                scene.rotation.y = currentRotation.y;
                
                requestAnimationFrame(updateRotation);
            }
            updateRotation();

            function onStart(event) {
                isDragging = true;
                previousPosition = getPosition(event);
                event.preventDefault();
            }

            function onMove(event) {
                if (!isDragging) return;

                const currentPosition = getPosition(event);
                const deltaMove = {
                    x: currentPosition.x - previousPosition.x,
                    y: currentPosition.y - previousPosition.y
                };

                const rotationSpeed = 0.005;
                scene.rotation.y += deltaMove.x * rotationSpeed;
                scene.rotation.x += deltaMove.y * rotationSpeed;

                // Limit vertical rotation to avoid flipping
                scene.rotation.x = Math.max(-Math.PI/3, Math.min(Math.PI/3, scene.rotation.x));

                previousPosition = currentPosition;
                event.preventDefault();
            }

            function onEnd(event) {
                isDragging = false;
                event.preventDefault();
            }

            // Touch events
            document.addEventListener('touchstart', onStart, { passive: false });
            document.addEventListener('touchmove', onMove, { passive: false });
            document.addEventListener('touchend', onEnd, { passive: false });

            // Mouse events
            document.addEventListener('mousedown', onStart);
            document.addEventListener('mousemove', onMove);
            document.addEventListener('mouseup', onEnd);

            // Pinch to zoom for touch devices
            let initialPinchDistance = null;
            let initialZoom = 0;

            document.addEventListener('touchstart', (e) => {
                if (e.touches.length === 2) {
                    initialPinchDistance = Math.hypot(
                        e.touches[0].clientX - e.touches[1].clientX,
                        e.touches[0].clientY - e.touches[1].clientY
                    );
                    initialZoom = camera.position.z;
                    e.preventDefault();
                }
            }, { passive: false });

            document.addEventListener('touchmove', (e) => {
                if (e.touches.length === 2 && initialPinchDistance !== null) {
                    const currentDistance = Math.hypot(
                        e.touches[0].clientX - e.touches[1].clientX,
                        e.touches[0].clientY - e.touches[1].clientY
                    );
                    
                    const deltaZoom = (initialPinchDistance - currentDistance) * 0.05;
                    camera.position.z = Math.max(5, Math.min(50, initialZoom + deltaZoom));
                    e.preventDefault();
                }
            }, { passive: false });

            document.addEventListener('touchend', () => {
                initialPinchDistance = null;
            });

            // Mouse wheel zoom
            document.addEventListener('wheel', (e) => {
                const zoomSpeed = 0.001;
                camera.position.z += e.deltaY * zoomSpeed;
                camera.position.z = Math.max(5, Math.min(50, camera.position.z));
                e.preventDefault();
            }, { passive: false });
        }

        let lastFrameTime = 0;
        let frameCount = 0;
        
        function animate() {
            requestAnimationFrame(animate);
            
            try {
                const time = clock.getElapsedTime();
                const currentTime = performance.now();
                
                // Calculate FPS every second
                frameCount++;
                if (currentTime - lastFrameTime >= 1000) {
                    sendToiOS({
                        type: 'performance',
                        message: 'FPS: ' + frameCount,
                        time: currentTime
                    });
                    frameCount = 0;
                    lastFrameTime = currentTime;
                }
                
                // Animate objects
                animatedObjects.forEach(item => {
                const speed = item.speed || 1;
                switch (item.type) {
                    case 'rotate':
                        item.obj.rotation.y = time * 0.1 * speed;
                        break;
                    case 'sway':
                        item.obj.rotation.z = Math.sin(time * speed) * 0.08;
                        break;
                    case 'grow':
                        item.obj.scale.y = 1 + Math.sin(time * speed) * 0.05;
                        break;
                    case 'float':
                        item.obj.position.y += Math.sin(time * speed * 2) * 0.003;
                        break;
                    case 'glow':
                        if (item.obj.material) {
                            item.obj.material.opacity = 0.3 + Math.sin(time * speed) * 0.2;
                        }
                        break;
                    case 'pulse':
                        const scale = 1 + Math.sin(time * speed) * 0.1;
                        item.obj.scale.set(scale, scale, scale);
                        break;
                }
            });
            
            // Animate particles
            particles.forEach(particle => {
                particle.mesh.position.y += Math.sin(time * particle.speed) * 0.01;
                particle.mesh.rotation.y = time * 0.1;
                particle.mesh.material.opacity = 0.4 + Math.sin(time * particle.speed * 2) * 0.2;
            });

            renderer.render(scene, camera);
        }

        // Initialize everything
        init();

        // Handle window resizing
        window.addEventListener('resize', () => {
            const aspect = window.innerWidth / window.innerHeight;
            const d = 25;
            
            camera.left = -d * aspect;
            camera.right = d * aspect;
            camera.top = d;
            camera.bottom = -d;
            camera.updateProjectionMatrix();
            
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
